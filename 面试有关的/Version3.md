## 对于Spring的理解

#### 1.什么是Spring框架



**Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。**

**Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！**

> **题外话 ： 语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。**

**我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。**

**比如说 Spring 自带 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。**



#### 2.Spring中IOC和AOP的理解

**<1>  IOC控制反转**

就是将我们需要的对象实例化之后交给Spring来统一管理,哪些地方需要就对哪里依赖注入。

**<2>IOC的优势**

实现组件之间的解耦,就是降低了类与类之间的耦合度。提高程序的灵活性和可维护性

**--------------------------->什么是耦合度？**

**耦合度就是某模块（类）与其它模块（类）之间的关联、感知和依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。耦合的强度依赖于以下几个因素：**

**（1）一个模块对另一个模块的调用；**

**（2）一个模块向另一个模块传递的数据量；**

**（3）一个模块施加到另一个模块的控制的多少；**

**（4）模块之间接口的复杂程度。**



**<3>IOC为什么可以降低耦合度？**

总的来说：IOC = 工厂模式+反射+配置文件读取

所有的JavaBean都被IOC的工厂管理,你需要的时候就和工厂说一声我需要XXX就可以了,这样工厂就会返回给你一个正确的对象.在不需要的时候修改工厂的生产列表(配置文件),工厂就停止生产该JavaBean了.

可以参考以下博客：

https://blog.csdn.net/tinpo_123/article/details/108718367?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165200361416780357289530%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165200361416780357289530&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-108718367-null-null.142



**<4>控制反转思想前提 —— [依赖注入](https://so.csdn.net/so/search?q=依赖注入&spm=1001.2101.3001.7020)（DI）（一般都是set注入）**

Dependency Injection，说的是创建对象实例时，同时为这个对象注入它所依赖的属性。相当于把每个bean与bean之间的关系交给容器管理。而这个容器就是spring。
例如我们通常在 Service 层注入它所依赖的 Dao 层的实例；在 Controller层注入 Service层的实例。
DI 给对象属性赋值的过程叫做依赖注入！
![image-20220508181352322](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220508181352322.png)



<5>控制反转的思想---也就是依赖倒置的实现。

![image-20220508181445224](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220508181445224.png)



**以上就是依赖倒置的概念（我们调用方法时不需要考虑下一层的是怎么构造的，只需要new 下一层对象，只需要维护最底层即可）**



<5>**总结来说**

**spring 则是通过 IOC 容器来创建对象，也就是说我们将创建对象的控制权交给了 IOC 容器。我们可以用一句话来概括 IOC：**
**IOC 让程序员不在关注怎么去创建对象，而是关注与对象创建之后的操作，把对象的创建、初始化、销毁等工作交给spring容器来做。**







**AOP******面向切面的编程思想****

**<1>核心思想**

能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来**，便于**减少系统的重复代码**，**降低模块间的耦合度**，**并******有利于未来的可拓展性和可维护性**。**

**<2>为什么需要AOP**

想象下面的场景，开发中在多个模块间有某段重复的代码，我们通常是怎么处理的？显然，没有人会靠“复制粘贴”吧。在传统的面向过程编程中，我们也会将这段代码，抽象成一个方法，然后在需要的地方分别调用这个方法，这样当这段代码需要修改时，我们只需要改变这个方法就可以了。然而需求总是变化的，有一天，新增了一个需求，需要再多出做修改，我们需要再抽象出一个方法，然后再在需要的地方分别调用这个方法，又或者我们不需要这个方法了，我们还是得删除掉每一处调用该方法的地方。实际上涉及到多个地方具有相同的修改的问题我们都可以通过 AOP 来解决。

**<3>AOP 要达到的效果**

保证开发者不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。AOP 的本质是由 AOP 框架修改业务组件的多个方法的源代码，看到这其实应该明白了，AOP 其实就是代理模式的典型应用。
按照 AOP 框架修改源代码的时机，可以将其分为两类：

--静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ。
--动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。
